{"version":3,"file":"commands.js","mappings":"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","sources":["webpack://office-addin-taskpane-react/./node_modules/es6-promise/dist/es6-promise.js","webpack://office-addin-taskpane-react/webpack/bootstrap","webpack://office-addin-taskpane-react/webpack/runtime/global","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/version.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/_shims/registry.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/_shims/index.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/error.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/streaming.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/uploads.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/core.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resource.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/completions.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/pagination.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/models.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/beta/models.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs","webpack://office-addin-taskpane-react/./node_modules/@anthropic-ai/sdk/index.mjs","webpack://office-addin-taskpane-react/./src/taskpane/services/claudeai.ts","webpack://office-addin-taskpane-react/./src/taskpane/utilities/showNotification.ts","webpack://office-addin-taskpane-react/./src/taskpane/utilities/promptDialog.ts","webpack://office-addin-taskpane-react/./src/commands/commands.ts"],"sourcesContent":["/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","export const VERSION = '0.39.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map","export let auto = false;\nexport let kind = undefined;\nexport let fetch = undefined;\nexport let Request = undefined;\nexport let Response = undefined;\nexport let Headers = undefined;\nexport let FormData = undefined;\nexport let Blob = undefined;\nexport let File = undefined;\nexport let ReadableStream = undefined;\nexport let getMultipartRequestOptions = undefined;\nexport let getDefaultAgent = undefined;\nexport let fileFromPath = undefined;\nexport let isFsReadStream = undefined;\nexport function setShims(shims, options = { auto: false }) {\n    if (auto) {\n        throw new Error(`you must \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` before importing anything else from @anthropic-ai/sdk`);\n    }\n    if (kind) {\n        throw new Error(`can't \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` after \\`import '@anthropic-ai/sdk/shims/${kind}'\\``);\n    }\n    auto = options.auto;\n    kind = shims.kind;\n    fetch = shims.fetch;\n    Request = shims.Request;\n    Response = shims.Response;\n    Headers = shims.Headers;\n    FormData = shims.FormData;\n    Blob = shims.Blob;\n    File = shims.File;\n    ReadableStream = shims.ReadableStream;\n    getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    getDefaultAgent = shims.getDefaultAgent;\n    fileFromPath = shims.fileFromPath;\n    isFsReadStream = shims.isFsReadStream;\n}\n//# sourceMappingURL=registry.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n    constructor(body) {\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return 'MultipartBody';\n    }\n}\n//# sourceMappingURL=MultipartBody.mjs.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport * as shims from './registry.mjs';\nimport * as auto from '@anthropic-ai/sdk/_shims/auto/runtime';\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\nexport * from './registry.mjs';\n","import { MultipartBody } from \"./MultipartBody.mjs\";\nexport function getRuntime({ manuallyImported } = {}) {\n    const recommendation = manuallyImported ?\n        `You may need to use polyfills`\n        : `Add one of these imports before your first \\`import  from '@anthropic-ai/sdk'\\`:\n- \\`import '@anthropic-ai/sdk/shims/node'\\` (if you're running on Node)\n- \\`import '@anthropic-ai/sdk/shims/web'\\` (otherwise)\n`;\n    let _fetch, _Request, _Response, _Headers;\n    try {\n        // @ts-ignore\n        _fetch = fetch;\n        // @ts-ignore\n        _Request = Request;\n        // @ts-ignore\n        _Response = Response;\n        // @ts-ignore\n        _Headers = Headers;\n    }\n    catch (error) {\n        throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n    }\n    return {\n        kind: 'web',\n        fetch: _fetch,\n        Request: _Request,\n        Response: _Response,\n        Headers: _Headers,\n        FormData: \n        // @ts-ignore\n        typeof FormData !== 'undefined' ? FormData : (class FormData {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n            }\n        }),\n        Blob: typeof Blob !== 'undefined' ? Blob : (class Blob {\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n            }\n        }),\n        File: \n        // @ts-ignore\n        typeof File !== 'undefined' ? File : (class File {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n            }\n        }),\n        ReadableStream: \n        // @ts-ignore\n        typeof ReadableStream !== 'undefined' ? ReadableStream : (class ReadableStream {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n            }\n        }),\n        getMultipartRequestOptions: async (\n        // @ts-ignore\n        form, opts) => ({\n            ...opts,\n            body: new MultipartBody(form),\n        }),\n        getDefaultAgent: (url) => undefined,\n        fileFromPath: () => {\n            throw new Error('The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads');\n        },\n        isFsReadStream: (value) => false,\n    };\n}\n//# sourceMappingURL=web-runtime.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { castToError } from \"./core.mjs\";\nexport class AnthropicError extends Error {\n}\nexport class APIError extends AnthropicError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.['request-id'];\n        this.error = error;\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse;\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexport class APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nexport class APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexport class APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexport class BadRequestError extends APIError {\n}\nexport class AuthenticationError extends APIError {\n}\nexport class PermissionDeniedError extends APIError {\n}\nexport class NotFoundError extends APIError {\n}\nexport class ConflictError extends APIError {\n}\nexport class UnprocessableEntityError extends APIError {\n}\nexport class RateLimitError extends APIError {\n}\nexport class InternalServerError extends APIError {\n}\n//# sourceMappingURL=error.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LineDecoder_carriageReturnIndex;\nimport { AnthropicError } from \"../../error.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n    constructor() {\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        this.buffer = new Uint8Array();\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(this.buffer.length + binaryChunk.length);\n        newData.set(this.buffer);\n        newData.set(binaryChunk, this.buffer.length);\n        this.buffer = newData;\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"));\n                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = this.decodeText(this.buffer.slice(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.slice(patternIndex.index);\n            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null)\n            return '';\n        if (typeof bytes === 'string')\n            return bytes;\n        // Node:\n        if (typeof Buffer !== 'undefined') {\n            if (bytes instanceof Buffer) {\n                return bytes.toString();\n            }\n            if (bytes instanceof Uint8Array) {\n                return Buffer.from(bytes).toString();\n            }\n            throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== 'undefined') {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map","/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n//# sourceMappingURL=stream-utils.mjs.map","import { ReadableStream } from \"./_shims/index.mjs\";\nimport { AnthropicError } from \"./error.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"./internal/stream-utils.mjs\";\nimport { createResponseHeaders } from \"./core.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (sse.event === 'completion') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'message_start' ||\n                        sse.event === 'message_delta' ||\n                        sse.event === 'message_stop' ||\n                        sse.event === 'content_block_start' ||\n                        sse.event === 'content_block_delta' ||\n                        sse.event === 'content_block_stop') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'ping') {\n                        continue;\n                    }\n                    if (sse.event === 'error') {\n                        throw APIError.generate(undefined, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = ReadableStreamToAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new ReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexport async function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new AnthropicError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = ReadableStreamToAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map","import { FormData, File, getMultipartRequestOptions, isFsReadStream, } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\nexport const isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\nexport const isUploadable = (value) => {\n    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        return value;\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = isBlobLike(blob) ? [(await blob.arrayBuffer())] : [blob];\n        return new File(data, name, options);\n    }\n    const bits = await getBytes(value);\n    name || (name = getName(value) ?? 'unknown_file');\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return new File(bits, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(await value.arrayBuffer());\n    }\n    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(chunk); // TODO, consider validating?\n        }\n    }\n    else {\n        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n            ?.name}; props: ${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n    return (getStringFromMaybeBuffer(value.name) ||\n        getStringFromMaybeBuffer(value.filename) ||\n        // For fs.ReadStream\n        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = (x) => {\n    if (typeof x === 'string')\n        return x;\n    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n        return String(x);\n    return undefined;\n};\nconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nexport const isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async (opts) => {\n    const form = await createForm(opts.body);\n    return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async (body) => {\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (isUploadable(value)) {\n        const file = await toFile(value);\n        form.append(key, file);\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { AnthropicError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch, } from \"./_shims/index.mjs\";\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const isJSON = contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:\n     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\n     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:\n     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\n     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overriddenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overriddenFetch ?? fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(options, { retryCount = 0 } = {}) {\n        options = { ...options };\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : isMultipartBody(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n        const minAgentTimeout = options.timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if (isMultipartBody(options.body) && shimsKind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set theses headers if they were already set or removed through default headers or by the caller.\n        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n        // for the removal case.\n        if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n            getHeader(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n            getHeader(headers, 'x-stainless-timeout') === undefined &&\n            options.timeout) {\n            reqHeaders['x-stainless-timeout'] = String(options.timeout);\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    _calculateNonstreamingTimeout(maxTokens) {\n        const defaultTimeout = 10 * 60;\n        const expectedTimeout = (60 * 60 * maxTokens) / 128000;\n        if (expectedTimeout > defaultTimeout) {\n            throw new AnthropicError('Streaming is strongly recommended for operations that may take longer than 10 minutes. ' +\n                'See https://github.com/anthropics/anthropic-sdk-python#streaming-responses for more details');\n        }\n        return defaultTimeout * 1000;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => castToError(e).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...options,\n        };\n        if (fetchOptions.method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = fetchOptions.method.toUpperCase();\n        }\n        // turn on TCP keep-alive for the sockets, if the runtime supports it\n        const socketKeepAliveInterval = 60 * 1000;\n        const keepAliveTimeout = setTimeout(() => {\n            if (fetchOptions && fetchOptions?.agent?.sockets) {\n                for (const socket of Object.values(fetchOptions?.agent?.sockets).flat()) {\n                    if (socket?.setKeepAlive) {\n                        socket.setKeepAlive(true, socketKeepAliveInterval);\n                    }\n                }\n            }\n        }, socketKeepAliveInterval);\n        return (\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        this.fetch.call(undefined, url, fetchOptions).finally(() => {\n            clearTimeout(timeout);\n            clearTimeout(keepAliveTimeout);\n        }));\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n}\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new AnthropicError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport const createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new AnthropicError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new AnthropicError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(String(err));\n};\nexport const ensurePresent = (value) => {\n    if (value == null)\n        throw new AnthropicError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nexport function debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        console.log(`Anthropic:DEBUG:${action}`, ...args);\n    }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexport const isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n    const foundHeader = getHeader(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if (isHeadersProtocol(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new AnthropicError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n//# sourceMappingURL=core.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport class APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nexport class Completions extends APIResource {\n    create(body, options) {\n        return this._client.post('/v1/complete', {\n            body,\n            timeout: this._client._options.timeout ?? 600000,\n            ...options,\n            stream: body.stream ?? false,\n        });\n    }\n}\n//# sourceMappingURL=completions.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { AbstractPage } from \"./core.mjs\";\nexport class Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n        this.first_id = body.first_id || null;\n        this.last_id = body.last_id || null;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info)\n            return null;\n        if ('params' in info)\n            return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length)\n            return null;\n        return params;\n    }\n    nextPageInfo() {\n        if (this.options.query?.['before_id']) {\n            // in reverse\n            const firstId = this.first_id;\n            if (!firstId) {\n                return null;\n            }\n            return {\n                params: {\n                    before_id: firstId,\n                },\n            };\n        }\n        const cursor = this.last_id;\n        if (!cursor) {\n            return null;\n        }\n        return {\n            params: {\n                after_id: cursor,\n            },\n        };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map","import { AnthropicError } from \"../../error.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"../stream-utils.mjs\";\nimport { LineDecoder } from \"./line.mjs\";\nexport class JSONLDecoder {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    async *decoder() {\n        const lineDecoder = new LineDecoder();\n        for await (const chunk of this.iterator) {\n            for (const line of lineDecoder.decode(chunk)) {\n                yield JSON.parse(line);\n            }\n        }\n        for (const line of lineDecoder.flush()) {\n            yield JSON.parse(line);\n        }\n    }\n    [Symbol.asyncIterator]() {\n        return this.decoder();\n    }\n    static fromResponse(response, controller) {\n        if (!response.body) {\n            controller.abort();\n            throw new AnthropicError(`Attempted to iterate over a response with no body`);\n        }\n        return new JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);\n    }\n}\n//# sourceMappingURL=jsonl.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { Page } from \"../../pagination.mjs\";\nimport { JSONLDecoder } from \"../../internal/decoders/jsonl.mjs\";\nimport { AnthropicError } from \"../../error.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    create(body, options) {\n        return this._client.post('/v1/messages/batches', { body, ...options });\n    }\n    /**\n     * This endpoint is idempotent and can be used to poll for Message Batch\n     * completion. To access the results of a Message Batch, make a request to the\n     * `results_url` field in the response.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    retrieve(messageBatchId, options) {\n        return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/v1/messages/batches', MessageBatchesPage, { query, ...options });\n    }\n    /**\n     * Delete a Message Batch.\n     *\n     * Message Batches can only be deleted once they've finished processing. If you'd\n     * like to delete an in-progress batch, you must first cancel it.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    delete(messageBatchId, options) {\n        return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);\n    }\n    /**\n     * Batches may be canceled any time before processing ends. Once cancellation is\n     * initiated, the batch enters a `canceling` state, at which time the system may\n     * complete any in-progress, non-interruptible requests before finalizing\n     * cancellation.\n     *\n     * The number of canceled requests is specified in `request_counts`. To determine\n     * which requests were canceled, check the individual results within the batch.\n     * Note that cancellation may not result in any canceled requests if they were\n     * non-interruptible.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    cancel(messageBatchId, options) {\n        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);\n    }\n    /**\n     * Streams the results of a Message Batch as a `.jsonl` file.\n     *\n     * Each line in the file is a JSON object containing the result of a single request\n     * in the Message Batch. Results are not guaranteed to be in the same order as\n     * requests. Use the `custom_id` field to match results to requests.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    async results(messageBatchId, options) {\n        const batch = await this.retrieve(messageBatchId);\n        if (!batch.results_url) {\n            throw new AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: {\n                Accept: 'application/binary',\n                ...options?.headers,\n            },\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\nexport class MessageBatchesPage extends Page {\n}\nBatches.MessageBatchesPage = MessageBatchesPage;\n//# sourceMappingURL=batches.mjs.map","const tokenize = (input) => {\n    let current = 0;\n    let tokens = [];\n    while (current < input.length) {\n        let char = input[current];\n        if (char === '\\\\') {\n            current++;\n            continue;\n        }\n        if (char === '{') {\n            tokens.push({\n                type: 'brace',\n                value: '{',\n            });\n            current++;\n            continue;\n        }\n        if (char === '}') {\n            tokens.push({\n                type: 'brace',\n                value: '}',\n            });\n            current++;\n            continue;\n        }\n        if (char === '[') {\n            tokens.push({\n                type: 'paren',\n                value: '[',\n            });\n            current++;\n            continue;\n        }\n        if (char === ']') {\n            tokens.push({\n                type: 'paren',\n                value: ']',\n            });\n            current++;\n            continue;\n        }\n        if (char === ':') {\n            tokens.push({\n                type: 'separator',\n                value: ':',\n            });\n            current++;\n            continue;\n        }\n        if (char === ',') {\n            tokens.push({\n                type: 'delimiter',\n                value: ',',\n            });\n            current++;\n            continue;\n        }\n        if (char === '\"') {\n            let value = '';\n            let danglingQuote = false;\n            char = input[++current];\n            while (char !== '\"') {\n                if (current === input.length) {\n                    danglingQuote = true;\n                    break;\n                }\n                if (char === '\\\\') {\n                    current++;\n                    if (current === input.length) {\n                        danglingQuote = true;\n                        break;\n                    }\n                    value += char + input[current];\n                    char = input[++current];\n                }\n                else {\n                    value += char;\n                    char = input[++current];\n                }\n            }\n            char = input[++current];\n            if (!danglingQuote) {\n                tokens.push({\n                    type: 'string',\n                    value,\n                });\n            }\n            continue;\n        }\n        let WHITESPACE = /\\s/;\n        if (char && WHITESPACE.test(char)) {\n            current++;\n            continue;\n        }\n        let NUMBERS = /[0-9]/;\n        if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\n            let value = '';\n            if (char === '-') {\n                value += char;\n                char = input[++current];\n            }\n            while ((char && NUMBERS.test(char)) || char === '.') {\n                value += char;\n                char = input[++current];\n            }\n            tokens.push({\n                type: 'number',\n                value,\n            });\n            continue;\n        }\n        let LETTERS = /[a-z]/i;\n        if (char && LETTERS.test(char)) {\n            let value = '';\n            while (char && LETTERS.test(char)) {\n                if (current === input.length) {\n                    break;\n                }\n                value += char;\n                char = input[++current];\n            }\n            if (value == 'true' || value == 'false' || value === 'null') {\n                tokens.push({\n                    type: 'name',\n                    value,\n                });\n            }\n            else {\n                // unknown token, e.g. `nul` which isn't quite `null`\n                current++;\n                continue;\n            }\n            continue;\n        }\n        current++;\n    }\n    return tokens;\n}, strip = (tokens) => {\n    if (tokens.length === 0) {\n        return tokens;\n    }\n    let lastToken = tokens[tokens.length - 1];\n    switch (lastToken.type) {\n        case 'separator':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n        case 'number':\n            let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n            if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n        case 'string':\n            let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n            if (tokenBeforeTheLastToken?.type === 'delimiter') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            break;\n        case 'delimiter':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n    }\n    return tokens;\n}, unstrip = (tokens) => {\n    let tail = [];\n    tokens.map((token) => {\n        if (token.type === 'brace') {\n            if (token.value === '{') {\n                tail.push('}');\n            }\n            else {\n                tail.splice(tail.lastIndexOf('}'), 1);\n            }\n        }\n        if (token.type === 'paren') {\n            if (token.value === '[') {\n                tail.push(']');\n            }\n            else {\n                tail.splice(tail.lastIndexOf(']'), 1);\n            }\n        }\n    });\n    if (tail.length > 0) {\n        tail.reverse().map((item) => {\n            if (item === '}') {\n                tokens.push({\n                    type: 'brace',\n                    value: '}',\n                });\n            }\n            else if (item === ']') {\n                tokens.push({\n                    type: 'paren',\n                    value: ']',\n                });\n            }\n        });\n    }\n    return tokens;\n}, generate = (tokens) => {\n    let output = '';\n    tokens.map((token) => {\n        switch (token.type) {\n            case 'string':\n                output += '\"' + token.value + '\"';\n                break;\n            default:\n                output += token.value;\n                break;\n        }\n    });\n    return output;\n}, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));\nexport { partialParse };\n//# sourceMappingURL=parser.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class MessageStream {\n    constructor() {\n        _MessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _MessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _MessageStream_connectedPromise.set(this, void 0);\n        _MessageStream_resolveConnectedPromise.set(this, () => { });\n        _MessageStream_rejectConnectedPromise.set(this, () => { });\n        _MessageStream_endPromise.set(this, void 0);\n        _MessageStream_resolveEndPromise.set(this, () => { });\n        _MessageStream_rejectEndPromise.set(this, () => { });\n        _MessageStream_listeners.set(this, {});\n        _MessageStream_ended.set(this, false);\n        _MessageStream_errored.set(this, false);\n        _MessageStream_aborted.set(this, false);\n        _MessageStream_catchingPromiseCreated.set(this, false);\n        _MessageStream_response.set(this, void 0);\n        _MessageStream_request_id.set(this, void 0);\n        _MessageStream_handleError.set(this, (error) => {\n            __classPrivateFieldSet(this, _MessageStream_errored, true, \"f\");\n            if (error instanceof Error && error.name === 'AbortError') {\n                error = new APIUserAbortError();\n            }\n            if (error instanceof APIUserAbortError) {\n                __classPrivateFieldSet(this, _MessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new AnthropicError(String(error)));\n        });\n        __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return __classPrivateFieldGet(this, _MessageStream_response, \"f\");\n    }\n    get request_id() {\n        return __classPrivateFieldGet(this, _MessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new MessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new MessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, __classPrivateFieldGet(this, _MessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n        const { response, data: stream } = await messages\n            .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n            .withResponse();\n        this._connected(response);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _MessageStream_response, response, \"f\");\n        __classPrivateFieldSet(this, _MessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _MessageStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _MessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _MessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if (__classPrivateFieldGet(this, _MessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _MessageStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n        this._connected(null);\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n    }\n    [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_response = new WeakMap(), _MessageStream_request_id = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (content.type === 'tool_use' && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n        if (this.ended) {\n            throw new AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new AnthropicError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n        let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push(event.content_block);\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.text += event.delta.text;\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.citations ?? (snapshotContent.citations = []);\n                            snapshotContent.citations.push(event.delta.citation);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent?.type === 'tool_use') {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                snapshotContent.input = partialParse(jsonBuf);\n                            }\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.thinking += event.delta.thinking;\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.signature = event.delta.signature;\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=MessageStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as BatchesAPI from \"./batches.mjs\";\nimport { Batches, MessageBatchesPage, } from \"./batches.mjs\";\nimport { MessageStream } from \"../../lib/MessageStream.mjs\";\nexport { MessageStream } from \"../../lib/MessageStream.mjs\";\nexport class Messages extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new BatchesAPI.Batches(this._client);\n    }\n    create(body, options) {\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        return this._client.post('/v1/messages', {\n            body,\n            timeout: this._client._options.timeout ??\n                (body.stream ? 600000 : this._client._calculateNonstreamingTimeout(body.max_tokens)),\n            ...options,\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return MessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     */\n    countTokens(body, options) {\n        return this._client.post('/v1/messages/count_tokens', { body, ...options });\n    }\n}\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n};\nMessages.Batches = Batches;\nMessages.MessageBatchesPage = MessageBatchesPage;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../resource.mjs\";\nimport { isRequestOptions } from \"../core.mjs\";\nimport { Page } from \"../pagination.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     */\n    retrieve(modelId, options) {\n        return this._client.get(`/v1/models/${modelId}`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/v1/models', ModelInfosPage, { query, ...options });\n    }\n}\nexport class ModelInfosPage extends Page {\n}\nModels.ModelInfosPage = ModelInfosPage;\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport { isRequestOptions } from \"../../core.mjs\";\nimport { Page } from \"../../pagination.mjs\";\nexport class Models extends APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     */\n    retrieve(modelId, options) {\n        return this._client.get(`/v1/models/${modelId}?beta=true`, options);\n    }\n    list(query = {}, options) {\n        if (isRequestOptions(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/v1/models?beta=true', BetaModelInfosPage, { query, ...options });\n    }\n}\nexport class BetaModelInfosPage extends Page {\n}\nModels.BetaModelInfosPage = BetaModelInfosPage;\n//# sourceMappingURL=models.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport { isRequestOptions } from \"../../../core.mjs\";\nimport { Page } from \"../../../pagination.mjs\";\nimport { JSONLDecoder } from \"../../../internal/decoders/jsonl.mjs\";\nimport { AnthropicError } from \"../../../error.mjs\";\nexport class Batches extends APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     */\n    create(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/batches?beta=true', {\n            body,\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n    retrieve(messageBatchId, params = {}, options) {\n        if (isRequestOptions(params)) {\n            return this.retrieve(messageBatchId, {}, params);\n        }\n        const { betas } = params;\n        return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n    list(params = {}, options) {\n        if (isRequestOptions(params)) {\n            return this.list({}, params);\n        }\n        const { betas, ...query } = params;\n        return this._client.getAPIList('/v1/messages/batches?beta=true', BetaMessageBatchesPage, {\n            query,\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n    delete(messageBatchId, params = {}, options) {\n        if (isRequestOptions(params)) {\n            return this.delete(messageBatchId, {}, params);\n        }\n        const { betas } = params;\n        return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n    cancel(messageBatchId, params = {}, options) {\n        if (isRequestOptions(params)) {\n            return this.cancel(messageBatchId, {}, params);\n        }\n        const { betas } = params;\n        return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n    async results(messageBatchId, params = {}, options) {\n        if (isRequestOptions(params)) {\n            return this.results(messageBatchId, {}, params);\n        }\n        const batch = await this.retrieve(messageBatchId);\n        if (!batch.results_url) {\n            throw new AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        const { betas } = params;\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                Accept: 'application/binary',\n                ...options?.headers,\n            },\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\nexport class BetaMessageBatchesPage extends Page {\n}\nBatches.BetaMessageBatchesPage = BetaMessageBatchesPage;\n//# sourceMappingURL=batches.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class BetaMessageStream {\n    constructor() {\n        _BetaMessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _BetaMessageStream_connectedPromise.set(this, void 0);\n        _BetaMessageStream_resolveConnectedPromise.set(this, () => { });\n        _BetaMessageStream_rejectConnectedPromise.set(this, () => { });\n        _BetaMessageStream_endPromise.set(this, void 0);\n        _BetaMessageStream_resolveEndPromise.set(this, () => { });\n        _BetaMessageStream_rejectEndPromise.set(this, () => { });\n        _BetaMessageStream_listeners.set(this, {});\n        _BetaMessageStream_ended.set(this, false);\n        _BetaMessageStream_errored.set(this, false);\n        _BetaMessageStream_aborted.set(this, false);\n        _BetaMessageStream_catchingPromiseCreated.set(this, false);\n        _BetaMessageStream_response.set(this, void 0);\n        _BetaMessageStream_request_id.set(this, void 0);\n        _BetaMessageStream_handleError.set(this, (error) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_errored, true, \"f\");\n            if (error instanceof Error && error.name === 'AbortError') {\n                error = new APIUserAbortError();\n            }\n            if (error instanceof APIUserAbortError) {\n                __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new AnthropicError(String(error)));\n        });\n        __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_response, \"f\");\n    }\n    get request_id() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new BetaMessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new BetaMessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n        const { response, data: stream } = await messages\n            .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n            .withResponse();\n        this._connected(response);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _BetaMessageStream_response, response, \"f\");\n        __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if (__classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _BetaMessageStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n        this._connected(null);\n        const stream = Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n    }\n    [(_BetaMessageStream_currentMessageSnapshot = new WeakMap(), _BetaMessageStream_connectedPromise = new WeakMap(), _BetaMessageStream_resolveConnectedPromise = new WeakMap(), _BetaMessageStream_rejectConnectedPromise = new WeakMap(), _BetaMessageStream_endPromise = new WeakMap(), _BetaMessageStream_resolveEndPromise = new WeakMap(), _BetaMessageStream_rejectEndPromise = new WeakMap(), _BetaMessageStream_listeners = new WeakMap(), _BetaMessageStream_ended = new WeakMap(), _BetaMessageStream_errored = new WeakMap(), _BetaMessageStream_aborted = new WeakMap(), _BetaMessageStream_catchingPromiseCreated = new WeakMap(), _BetaMessageStream_response = new WeakMap(), _BetaMessageStream_request_id = new WeakMap(), _BetaMessageStream_handleError = new WeakMap(), _BetaMessageStream_instances = new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (content.type === 'tool_use' && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest() {\n        if (this.ended) {\n            throw new AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new AnthropicError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage(event) {\n        let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push(event.content_block);\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.text += event.delta.text;\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshotContent.citations ?? (snapshotContent.citations = []);\n                            snapshotContent.citations.push(event.delta.citation);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent?.type === 'tool_use') {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                snapshotContent.input = partialParse(jsonBuf);\n                            }\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.thinking += event.delta.thinking;\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshotContent.signature = event.delta.signature;\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=BetaMessageStream.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../../resource.mjs\";\nimport * as BatchesAPI from \"./batches.mjs\";\nimport { Batches, BetaMessageBatchesPage, } from \"./batches.mjs\";\nimport { BetaMessageStream } from \"../../../lib/BetaMessageStream.mjs\";\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n};\nexport class Messages extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new BatchesAPI.Batches(this._client);\n    }\n    create(params, options) {\n        const { betas, ...body } = params;\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        return this._client.post('/v1/messages?beta=true', {\n            body,\n            timeout: this._client._options.timeout ??\n                (body.stream ? 600000 : this._client._calculateNonstreamingTimeout(body.max_tokens)),\n            ...options,\n            headers: {\n                ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined),\n                ...options?.headers,\n            },\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return BetaMessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     */\n    countTokens(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/count_tokens?beta=true', {\n            body,\n            ...options,\n            headers: {\n                'anthropic-beta': [...(betas ?? []), 'token-counting-2024-11-01'].toString(),\n                ...options?.headers,\n            },\n        });\n    }\n}\nMessages.Batches = Batches;\nMessages.BetaMessageBatchesPage = BetaMessageBatchesPage;\n//# sourceMappingURL=messages.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../resource.mjs\";\nimport * as ModelsAPI from \"./models.mjs\";\nimport { BetaModelInfosPage, Models } from \"./models.mjs\";\nimport * as MessagesAPI from \"./messages/messages.mjs\";\nimport { Messages, } from \"./messages/messages.mjs\";\nexport class Beta extends APIResource {\n    constructor() {\n        super(...arguments);\n        this.models = new ModelsAPI.Models(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n}\nBeta.Models = Models;\nBeta.BetaModelInfosPage = BetaModelInfosPage;\nBeta.Messages = Messages;\n//# sourceMappingURL=beta.mjs.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _a;\nimport * as Core from \"./core.mjs\";\nimport * as Errors from \"./error.mjs\";\nimport * as Pagination from \"./pagination.mjs\";\nimport * as Uploads from \"./uploads.mjs\";\nimport * as API from \"./resources/index.mjs\";\nimport { Completions, } from \"./resources/completions.mjs\";\nimport { ModelInfosPage, Models } from \"./resources/models.mjs\";\nimport { Beta, } from \"./resources/beta/beta.mjs\";\nimport { Messages, } from \"./resources/messages/messages.mjs\";\n/**\n * API Client for interfacing with the Anthropic API.\n */\nexport class Anthropic extends Core.APIClient {\n    /**\n     * API Client for interfacing with the Anthropic API.\n     *\n     * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]\n     * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]\n     * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('ANTHROPIC_BASE_URL'), apiKey = Core.readEnv('ANTHROPIC_API_KEY') ?? null, authToken = Core.readEnv('ANTHROPIC_AUTH_TOKEN') ?? null, ...opts } = {}) {\n        const options = {\n            apiKey,\n            authToken,\n            ...opts,\n            baseURL: baseURL || `https://api.anthropic.com`,\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n            throw new Errors.AnthropicError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\\n\");\n        }\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch,\n        });\n        this.completions = new API.Completions(this);\n        this.messages = new API.Messages(this);\n        this.models = new API.Models(this);\n        this.beta = new API.Beta(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.authToken = authToken;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            ...(this._options.dangerouslyAllowBrowser ?\n                { 'anthropic-dangerous-direct-browser-access': 'true' }\n                : undefined),\n            'anthropic-version': '2023-06-01',\n            ...this._options.defaultHeaders,\n        };\n    }\n    validateHeaders(headers, customHeaders) {\n        if (this.apiKey && headers['x-api-key']) {\n            return;\n        }\n        if (customHeaders['x-api-key'] === null) {\n            return;\n        }\n        if (this.authToken && headers['authorization']) {\n            return;\n        }\n        if (customHeaders['authorization'] === null) {\n            return;\n        }\n        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the \"X-Api-Key\" or \"Authorization\" headers to be explicitly omitted');\n    }\n    authHeaders(opts) {\n        const apiKeyAuth = this.apiKeyAuth(opts);\n        const bearerAuth = this.bearerAuth(opts);\n        if (apiKeyAuth != null && !Core.isEmptyObj(apiKeyAuth)) {\n            return apiKeyAuth;\n        }\n        if (bearerAuth != null && !Core.isEmptyObj(bearerAuth)) {\n            return bearerAuth;\n        }\n        return {};\n    }\n    apiKeyAuth(opts) {\n        if (this.apiKey == null) {\n            return {};\n        }\n        return { 'X-Api-Key': this.apiKey };\n    }\n    bearerAuth(opts) {\n        if (this.authToken == null) {\n            return {};\n        }\n        return { Authorization: `Bearer ${this.authToken}` };\n    }\n}\n_a = Anthropic;\nAnthropic.Anthropic = _a;\nAnthropic.HUMAN_PROMPT = '\\n\\nHuman:';\nAnthropic.AI_PROMPT = '\\n\\nAssistant:';\nAnthropic.DEFAULT_TIMEOUT = 600000; // 10 minutes\nAnthropic.AnthropicError = Errors.AnthropicError;\nAnthropic.APIError = Errors.APIError;\nAnthropic.APIConnectionError = Errors.APIConnectionError;\nAnthropic.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nAnthropic.APIUserAbortError = Errors.APIUserAbortError;\nAnthropic.NotFoundError = Errors.NotFoundError;\nAnthropic.ConflictError = Errors.ConflictError;\nAnthropic.RateLimitError = Errors.RateLimitError;\nAnthropic.BadRequestError = Errors.BadRequestError;\nAnthropic.AuthenticationError = Errors.AuthenticationError;\nAnthropic.InternalServerError = Errors.InternalServerError;\nAnthropic.PermissionDeniedError = Errors.PermissionDeniedError;\nAnthropic.UnprocessableEntityError = Errors.UnprocessableEntityError;\nAnthropic.toFile = Uploads.toFile;\nAnthropic.fileFromPath = Uploads.fileFromPath;\nAnthropic.Completions = Completions;\nAnthropic.Messages = Messages;\nAnthropic.Models = Models;\nAnthropic.ModelInfosPage = ModelInfosPage;\nAnthropic.Beta = Beta;\nexport const { HUMAN_PROMPT, AI_PROMPT } = Anthropic;\nexport { toFile, fileFromPath } from \"./uploads.mjs\";\nexport { AnthropicError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, NotFoundError, ConflictError, RateLimitError, BadRequestError, AuthenticationError, InternalServerError, PermissionDeniedError, UnprocessableEntityError, } from \"./error.mjs\";\nexport default Anthropic;\n//# sourceMappingURL=index.mjs.map","import Anthropic from '@anthropic-ai/sdk';\r\n\r\nconst anthropic = new Anthropic({\r\n    apiKey: \"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\",\r\n    dangerouslyAllowBrowser: true,\r\n});\r\n\r\n// Type guard to extract text from content blocks\r\nconst extractTextFromContent = (content: any[]): string => {\r\n    return content\r\n        .filter((block) => block.type === \"text\" && typeof block.text === \"string\")\r\n        .map((block) => block.text)\r\n        .join(\"\\n\")\r\n        .trim();\r\n};\r\n\r\nexport const generateMailBody = (promptToEnhanceMailBody: string, callback: (error: Error | null, result?: string) => void): void => {\r\n    const prompt = `Improve the following email body by making it more professional using this prompt:\\n\\n \"${promptToEnhanceMailBody}\"\\n\\n\r\n        Please do not return subject only return the improved body of the email without any extra text or introduction.`;\r\n\r\n    anthropic.messages\r\n        .create({\r\n            model: \"claude-3-7-sonnet-20250219\",\r\n            max_tokens: 1024,\r\n            messages: [{ role: \"user\", content: prompt }],\r\n        })\r\n        .then((response) => {\r\n            const text = extractTextFromContent(response.content || []);\r\n            callback(null, text || \"[No readable content from Claude]\");\r\n        })\r\n        .catch((error) => {\r\n            console.error(\"Claude API Error:\", error);\r\n            callback(error, null);\r\n        });\r\n};","export const showNotification = (key: string, message: string) => {\r\n    Office.context.mailbox.item.notificationMessages.replaceAsync(key, {\r\n        type: Office.MailboxEnums.ItemNotificationMessageType.InformationalMessage,\r\n        message: message,\r\n        icon: \"Icon.80x80\",\r\n        persistent: false,\r\n    });\r\n}","export const promptDialog = (onPromptReceived: (message: string) => void) => {\r\n    Office.context.ui.displayDialogAsync(\r\n        \"https://ompie00.github.io/ompie.ai/assets/promptDialog.html\",\r\n        { height: 50, width: 50 },\r\n        (asyncResult) => {\r\n            const dialog = asyncResult.value;\r\n\r\n            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: any) => {\r\n                dialog.close();\r\n\r\n                if (\"message\" in arg && typeof arg.message === \"string\") {\r\n                    onPromptReceived(arg.message);\r\n                } else {\r\n                    console.error(\"Dialog did not return a valid message:\", arg);\r\n                    onPromptReceived(\"\");\r\n                }\r\n            });\r\n        }\r\n    );\r\n};","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global Office */\n\nOffice.onReady(() => {\n  // If needed, Office.js is ready to be called.\n});\n\n/**\n * Shows a notification when the add-in command is executed.\n * @param event\n */\n\nimport { generateMailBody } from \"../taskpane/services/claudeai\";\nimport { showNotification } from \"../taskpane/utilities/showNotification\";\nimport { promptDialog } from \"../taskpane/utilities/promptDialog\";\n\nconst action = async (event: Office.AddinCommands.Event) => {\n  try {\n    const item = Office.context.mailbox.item;\n    const apiKey = localStorage.getItem('api_key');\n\n    if (!apiKey) {\n      // If no API key, open dialog with API key input\n      promptDialog((userPrompt) => {\n        if (!userPrompt) {\n          showNotification(\"Prompt Error\", \"No input received.\");\n          event.completed();\n          return;\n        }\n\n        generateMailBody(userPrompt, (error, improvedText) => {\n          if (error || !improvedText) {\n            console.error(\"Claude AI Error:\", error);\n            showNotification(\"AI Error\", \"Failed to generate AI response.\");\n            event.completed();\n            return;\n          }\n\n          item.body.setAsync(improvedText, { coercionType: \"text\" }, (setResult) => {\n            if (setResult.status !== Office.AsyncResultStatus.Succeeded) {\n              console.error(\"Failed to set body:\", setResult.error);\n              showNotification(\"Set Body Error\", \"Could not update the email body.\");\n            }\n            event.completed();\n          });\n        });\n      });\n      return;\n    }\n\n    item.body.getAsync(\"text\", (result) => {\n      if (result.status === Office.AsyncResultStatus.Succeeded) {\n        let mailBody = result.value?.trim();\n\n        if (mailBody) {\n          // Directly enhance existing mail body\n          generateMailBody(mailBody, (error, improvedText) => {\n            if (error || !improvedText) {\n              console.error(\"Claude AI Error:\", error);\n              showNotification(\"AI Error\", \"Failed to generate AI response.\");\n              event.completed();\n              return;\n            }\n\n            // Detect and preserve email header metadata if present\n            const fromIndex = mailBody.indexOf(\"From:\");\n            let cleanedBody = mailBody;\n\n            if (fromIndex !== -1) {\n              cleanedBody = mailBody.substring(fromIndex).trim();\n              cleanedBody = `${improvedText} \\n\\n${cleanedBody}`;\n\n              item.body.setAsync(cleanedBody, { coercionType: \"text\" }, (setResult) => {\n                if (setResult.status !== Office.AsyncResultStatus.Succeeded) {\n                  console.error(\"Failed to set body:\", setResult.error);\n                  showNotification(\"Set Body Error\", \"Could not update the email body.\");\n                }\n                event.completed();\n              });\n            } else {\n              console.warn(\"'From:' not found in the mail body.\");\n\n              item.body.setAsync(improvedText, { coercionType: \"text\" }, (setResult) => {\n                if (setResult.status !== Office.AsyncResultStatus.Succeeded) {\n                  console.error(\"Failed to set body:\", setResult.error);\n                  showNotification(\"Set Body Error\", \"Could not update the email body.\");\n                }\n                event.completed();\n              });\n            }\n          });\n        } else {\n          // Open dialog with just textarea when mail body is empty\n          promptDialog((userPrompt) => {\n            if (!userPrompt) {\n              showNotification(\"Prompt Error\", \"No input received.\");\n              event.completed();\n              return;\n            }\n\n            generateMailBody(userPrompt, (error, improvedText) => {\n              if (error || !improvedText) {\n                console.error(\"Claude AI Error:\", error);\n                showNotification(\"AI Error\", \"Failed to generate AI response.\");\n                event.completed();\n                return;\n              }\n\n              item.body.setAsync(improvedText, { coercionType: \"text\" }, (setResult) => {\n                if (setResult.status !== Office.AsyncResultStatus.Succeeded) {\n                  console.error(\"Failed to set body:\", setResult.error);\n                  showNotification(\"Set Body Error\", \"Could not update the email body.\");\n                }\n                event.completed();\n              });\n            });\n          });\n        }\n      } else {\n        console.error(\"Failed to get mail body:\", result.error);\n        showNotification(\"Body Retrieval Error\", \"Unable to retrieve the email content.\");\n        event.completed();\n      }\n    });\n  } catch (err) {\n    console.error(\"Unexpected error:\", err);\n    showNotification(\"Unexpected Error\", \"An error occurred. Please try again.\");\n    event.completed();\n  }\n};\n\nOffice.actions.associate(\"action\", action);"],"names":["module","exports","isFunction","x","isArray","Array","Object","prototype","toString","call","len","vertxNext","customSchedulerFn","asap","callback","arg","queue","flush","scheduleFlush","browserWindow","window","undefined","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","self","process","isWorker","Uint8ClampedArray","importScripts","MessageChannel","useSetTimeout","globalSetTimeout","setTimeout","i","channel","iterations","observer","node","then","onFulfillment","onRejection","parent","this","child","constructor","noop","PROMISE_ID","makePromise","_state","arguments","invokeCallback","_result","subscribe","resolve$1","object","promise","resolve","nextTick","document","createTextNode","observe","characterData","data","port1","onmessage","port2","postMessage","vertx","Function","require","runOnLoop","runOnContext","e","attemptVertx","Math","random","substring","PENDING","FULFILLED","REJECTED","handleMaybeThenable","maybeThenable","then$$1","thenable","fulfill","reject","value","reason","handleOwnThenable","sealed","error","fulfillmentHandler","rejectionHandler","tryThen","_label","handleForeignThenable","TypeError","type","publishRejection","_onerror","publish","_subscribers","length","subscribers","settled","detail","hasCallback","succeeded","id","Enumerator","Constructor","input","_instanceConstructor","_remaining","_enumerate","Error","_eachEntry","entry","c","resolve$$1","_then","didError","_settledAt","Promise$1","_willSettleAt","state","enumerator","Promise","resolver","needsResolver","initializePromise","needsNew","catch","finally","all","entries","race","_","_setScheduler","scheduleFn","_setAsap","asapFn","_asap","polyfill","local","g","P","promiseToString","cast","factory","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","globalThis","VERSION","kind","getDefaultAgent","fileFromPath","auto","MultipartBody","body","Symbol","toStringTag","shims","options","fetch","Request","Response","Headers","FormData","Blob","File","ReadableStream","getMultipartRequestOptions","isFsReadStream","manuallyImported","recommendation","_fetch","_Request","_Response","_Headers","message","async","form","opts","url","APIError","status","headers","super","makeMessage","request_id","msg","JSON","stringify","generate","errorResponse","APIConnectionError","cause","castToError","BadRequestError","AuthenticationError","PermissionDeniedError","NotFoundError","ConflictError","UnprocessableEntityError","RateLimitError","InternalServerError","APIUserAbortError","APIConnectionTimeoutError","_LineDecoder_carriageReturnIndex","__classPrivateFieldSet","receiver","f","has","set","__classPrivateFieldGet","get","LineDecoder","buffer","Uint8Array","decode","chunk","binaryChunk","ArrayBuffer","TextEncoder","encode","newData","lines","patternIndex","findNewlineIndex","carriage","index","push","decodeText","slice","endIndex","preceding","line","bytes","Buffer","from","name","TextDecoder","textDecoder","startIndex","findDoubleNewlineIndex","ReadableStreamToAsyncIterable","stream","asyncIterator","reader","getReader","next","result","read","done","releaseLock","cancelPromise","cancel","WeakMap","NEWLINE_CHARS","Set","NEWLINE_REGEXP","Stream","iterator","controller","fromSSEResponse","response","consumed","sse","abort","sseDecoder","SSEDecoder","lineDecoder","iter","sseChunk","iterSSEChunks","_iterSSEMessages","event","parse","console","raw","createResponseHeaders","fromReadableStream","readableStream","iterLines","tee","left","right","teeIterator","shift","toReadableStream","encoder","start","pull","ctrl","close","enqueue","err","return","chunks","endsWith","join","startsWith","fieldname","str","indexOf","delimiter","partition","isBlobLike","size","text","arrayBuffer","getStringFromMaybeBuffer","String","isAsyncIterableIterator","isMultipartBody","_AbstractPage_client","defaultParseResponse","props","debug","__streamClass","__binaryResponse","contentType","includes","json","_addRequestID","defineProperty","enumerable","APIPromise","responsePromise","parseResponse","_thenUnwrap","transform","asResponse","p","withResponse","parsedPromise","onfulfilled","onrejected","onfinally","APIClient","baseURL","maxRetries","timeout","httpAgent","overriddenFetch","validatePositiveInteger","authHeaders","defaultHeaders","Accept","getUserAgent","getPlatformHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","uuid4","path","methodRequest","post","patch","put","method","request","DataView","isView","getAPIList","Page","requestAPIList","calculateContentLength","byteLength","buildRequest","retryCount","query","__binaryRequest","contentLength","buildURL","minAgentTimeout","idempotencyHeader","idempotencyKey","req","buildHeaders","agent","signal","reqHeaders","applyHeadersMut","getHeader","_calculateNonstreamingTimeout","maxTokens","defaultTimeout","prepareOptions","prepareRequest","parseHeaders","fromEntries","map","header","makeStatusError","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","AbortController","fetchWithTimeout","retryRequest","responseHeaders","ok","shouldRetry","errText","errJSON","safeJSON","errMessage","PagePromise","isAbsoluteURL","URL","defaultQuery","isEmptyObj","search","stringifyQuery","filter","key","encodeURIComponent","init","ms","addEventListener","fetchOptions","toUpperCase","keepAliveTimeout","sockets","socket","values","flat","setKeepAlive","clearTimeout","shouldRetryHeader","timeoutMillis","retryAfterMillisHeader","timeoutMs","parseFloat","Number","isNaN","retryAfterHeader","timeoutSeconds","Date","now","calculateDefaultRetryTimeoutMillis","sleep","numRetries","min","pow","AbstractPage","client","hasNextPage","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","iterPages","page","item","Proxy","target","toLowerCase","requestOptionsKeys","isRequestOptions","obj","keys","every","k","hasOwn","normalizeArch","arch","normalizePlatform","platform","_platformHeaders","Deno","build","os","version","deno","EdgeRuntime","browserInfo","navigator","browserPatterns","pattern","match","exec","userAgent","browser","getBrowserInfo","getPlatformProperties","startsWithSchemeRegexp","test","n","isInteger","readEnv","env","trim","_k","hasOwnProperty","targetHeaders","newHeaders","lowerKey","val","action","args","log","replace","r","lowerCasedHeader","isHeadersProtocol","intercapsHeader","_m","g1","g2","warn","APIResource","_client","Completions","create","_options","has_more","first_id","last_id","nextPageParams","info","firstId","before_id","cursor","after_id","JSONLDecoder","decoder","fromResponse","Batches","retrieve","messageBatchId","list","MessageBatchesPage","delete","results","batch","results_url","processing_status","strip","tokens","lastToken","lastCharacterOfLastToken","tokenBeforeTheLastToken","partialParse","output","token","tail","splice","lastIndexOf","reverse","unstrip","current","char","danglingQuote","NUMBERS","LETTERS","tokenize","_MessageStream_instances","_MessageStream_currentMessageSnapshot","_MessageStream_connectedPromise","_MessageStream_resolveConnectedPromise","_MessageStream_rejectConnectedPromise","_MessageStream_endPromise","_MessageStream_resolveEndPromise","_MessageStream_rejectEndPromise","_MessageStream_listeners","_MessageStream_ended","_MessageStream_errored","_MessageStream_aborted","_MessageStream_catchingPromiseCreated","_MessageStream_response","_MessageStream_request_id","_MessageStream_getFinalMessage","_MessageStream_getFinalText","_MessageStream_handleError","_MessageStream_beginRequest","_MessageStream_addStreamEvent","_MessageStream_endRequest","_MessageStream_accumulateMessage","JSON_BUF_PROPERTY","MessageStream","add","messages","receivedMessages","_emit","anthropicError","runner","_run","_fromReadableStream","createMessage","_addMessageParam","_createMessage","executor","_emitFinal","_addMessage","emit","_connected","ended","errored","on","listener","off","listeners","findIndex","l","once","emitted","currentMessage","finalMessage","finalText","forEach","at","WeakSet","textBlocks","content","block","messageSnapshot","delta","citation","citations","partial_json","thinking","signature","snapshot","stop_reason","stop_sequence","usage","output_tokens","content_block","snapshotContent","jsonBuf","writable","pushQueue","readQueue","bind","Messages","batches","model","DEPRECATED_MODELS","max_tokens","countTokens","Models","modelId","ModelInfosPage","BetaModelInfosPage","betas","BetaMessageBatchesPage","_BetaMessageStream_instances","_BetaMessageStream_currentMessageSnapshot","_BetaMessageStream_connectedPromise","_BetaMessageStream_resolveConnectedPromise","_BetaMessageStream_rejectConnectedPromise","_BetaMessageStream_endPromise","_BetaMessageStream_resolveEndPromise","_BetaMessageStream_rejectEndPromise","_BetaMessageStream_listeners","_BetaMessageStream_ended","_BetaMessageStream_errored","_BetaMessageStream_aborted","_BetaMessageStream_catchingPromiseCreated","_BetaMessageStream_response","_BetaMessageStream_request_id","_BetaMessageStream_getFinalMessage","_BetaMessageStream_getFinalText","_BetaMessageStream_handleError","_BetaMessageStream_beginRequest","_BetaMessageStream_addStreamEvent","_BetaMessageStream_endRequest","_BetaMessageStream_accumulateMessage","BetaMessageStream","Beta","models","_a","Anthropic","apiKey","authToken","dangerouslyAllowBrowser","completions","beta","apiKeyAuth","bearerAuth","Authorization","HUMAN_PROMPT","AI_PROMPT","DEFAULT_TIMEOUT","AnthropicError","toFile","lastModified","isFileLike","blob","isResponseLike","pathname","split","pop","bits","parts","getOwnPropertyNames","propsForError","getBytes","filename","getName","anthropic","generateMailBody","promptToEnhanceMailBody","prompt","concat","role","showNotification","Office","context","mailbox","notificationMessages","replaceAsync","MailboxEnums","ItemNotificationMessageType","InformationalMessage","icon","persistent","promptDialog","onPromptReceived","ui","displayDialogAsync","height","width","asyncResult","dialog","addEventHandler","EventType","DialogMessageReceived","onReady","actions","associate","item_1","localStorage","getItem","userPrompt","completed","improvedText","setAsync","coercionType","setResult","AsyncResultStatus","Succeeded","getAsync","mailBody_1","fromIndex","cleanedBody"],"sourceRoot":""}